%%
%% %CopyrightBegin%
%%
%% Copyright Hillside Technology Ltd. 2016. All Rights Reserved.
%%
%% Licensed under the Apache License, Version 2.0 (the "License");
%% you may not use this file except in compliance with the License.
%% You may obtain a copy of the License at
%%
%%     http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing, software
%% distributed under the License is distributed on an "AS IS" BASIS,
%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%% See the License for the specific language governing permissions and
%% limitations under the License.
%%
%% %CopyrightEnd%
%%

%% Note: the file was generated, but after that the `do_test` function was 
%% modified to provide many different kind of responses, depending on the 
%% value of the 'expected_response' field.

%% generated by soap from: e:/e_soap/soap/test/soap_SUITE_data/test_service.wsdl
%% for service "test_service" and port "test_port"
%% using options: [{service,"test_service"},{port,"test_port"},{generate,both},{namespaces,[{"test",undefined}]},{http_server,soap_server_cowboy},{server_name,"test_service_server"},{http_client,soap_client_ibrowse},{client_name,"test_service_client"}]

-module(test_service_server).

-include("test_service.hrl").

-export([do_test/3]).
-export([interface/0]).
-export([exception/7]).

-spec do_test(Parsed_body::request_body(),
    Soap_req::soap:soap_req(), State::soap:soap_handler_state())
    -> soap:soap_handler_response(response_body()).
do_test(#request_body{expected_response="ok"}, Soap_req, State) ->
    {ok, #response_body{response="ok"}, Soap_req, State};
do_test(#request_body{expected_response="correct_header"}, Soap_req, State) ->
    {ok, #response_body{response="ok"}, ["<xml>test</xml>"], Soap_req, State};
do_test(#request_body{expected_response="encoded_header"}, Soap_req, State) ->
    {ok, #response_body{response="ok"}, [#header{header_field="hello"}], Soap_req, State};
do_test(#request_body{expected_response="two_headers"}, Soap_req, State) ->
    {ok, #response_body{response="ok"}, [#header{header_field="hello"}, "<xml xmlns=\"map\">test</xml>"], Soap_req, State};
do_test(#request_body{expected_response="one_header_one_skipped"}, Soap_req, State) ->
    {ok, #response_body{response="ok"}, [#header{header_field="hello"}, "<xml>test</xml>"], Soap_req, State};
do_test(#request_body{expected_response="fault_encoding_header"}, Soap_req, State) ->
    {ok, #response_body{response="ok"}, [#header{header_field=7}], Soap_req, State};
do_test(#request_body{expected_response="wrong_header"}, Soap_req, State) ->
    {ok, #response_body{response="ok"}, ["<not xml>"], Soap_req, State};
do_test(#request_body{expected_response="invalid_message"}, Soap_req, State) ->
    {ok, "<xml>This is not what the client expects</xml>", Soap_req, State};
do_test(#request_body{expected_response="sleep:"++Seconds}, Soap_req, State) ->
    timer:sleep(list_to_integer(string:strip(Seconds)) * 1000),
    {ok, #response_body{response="ok"}, Soap_req, State};
do_test(#request_body{expected_response="malformed_message"}, Soap_req, State) ->
    {ok, "<SOAP-ENV:Envelope xmlns:SOAP-ENV=http://schemas.xmlsoap.org/soap/envelope/>", 
     Soap_req, State};
do_test(#request_body{expected_response="405"}, Soap_req, State) ->
    {error, 405, Soap_req, State};
%% faults
do_test(#request_body{expected_response="client_fault"}, Soap_req, State) ->
    Fault = soap_fault:fault(client, "Client sent a wrong request", Soap_req),
    {fault, Fault, Soap_req, State};
do_test(#request_body{expected_response="server_fault"}, Soap_req, State) ->
    Fault = soap_fault:fault(server, "Server does not understand", Soap_req),
    {fault, Fault, Soap_req, State};
do_test(#request_body{expected_response="fault_w_actor"}, Soap_req, State) ->
    Fault = soap_fault:fault(server, "Fault with actor", [], "actor", Soap_req),
    {fault, Fault, Soap_req, State};
do_test(#request_body{expected_response="fault_w_special_code"}, Soap_req, State) ->
    Code = soap_fault:code("Name.space", "code"),
    Fault = soap_fault:fault(Code, "Server fault", [], undefined, Soap_req),
    {fault, Fault, Soap_req, State};
do_test(#request_body{expected_response="fault_w_details"}, Soap_req, State) ->
    Code = soap_fault:code("Name.space", "code"),
    Details = [soap_fault:detail("Name.space", "Pfx", "Tag", "The text"),
               soap_fault:detail("Name.space2", "Pfx2", "Tag2", "The second text")],
    Fault = soap_fault:fault(Code, "Fault with details", Details, undefined, Soap_req),
    {fault, Fault, Soap_req, State};
do_test(#request_body{expected_response="fault_1_2_simple"}, Soap_req, State) ->
    Code = server,
    String = "SOAP 1.2 fault",
    Details = [],
    Actor = undefined,
    Fault = soap_fault:fault(Code, String, Details, Actor, Soap_req),
    {fault, Fault, Soap_req, State};
do_test(#request_body{expected_response="fault_1_2_subcode"}, Soap_req, State) ->
    Subcode = soap_fault:code("uri", "code"),
    Code = soap_fault:code_with_subcode(server, Subcode),
    String = "SOAP 1.2 fault",
    Details = [],
    Actor = undefined,
    Fault = soap_fault:fault(Code, String, Details, Actor, Soap_req),
    {fault, Fault, Soap_req, State};
do_test(#request_body{expected_response="fault_1_2_actor"}, Soap_req, State) ->
    Subcode = soap_fault:code("uri", "code"),
    Code = soap_fault:code_with_subcode("http://www.w3.org/2003/05/soap-envelope", 
                                        "Receiver", Subcode),
    String = "SOAP 1.2 fault",
    Details = [soap_fault:detail("Name.space", "Pfx", "Tag", "The text"),
               soap_fault:detail("Name.space2", "Pfx2", "Tag2", "The second text")],
    Actor = "actor",
    Fault = soap_fault:fault(Code, String, Details, Actor, Soap_req),
    {fault, Fault, Soap_req, State};
do_test(#request_body{expected_response="raw"}, Soap_req, State) ->
    Raw_body = soap_req:http_body(Soap_req),
    {_Start, 3} = binary:match(Raw_body, <<"raw">>),
    Raw_resp = 
      <<"<env:Envelope xmlns:env=\"http://schemas.xmlsoap.org/soap/envelope/\"><env:Body><x:response_body xmlns:x=\"test\"><response>raw</response></x:response_body></env:Body></env:Envelope>">>,
    {raw, 200, Raw_resp, Soap_req, State};
do_test(#request_body{expected_response=Response}, Soap_req, State) when Response=="not_ok" ->
    %% trigger an exception
    case Response of
        "ok" ->
            {ok, #response_body{response="ok"}, Soap_req, State}
    end;
do_test(#request_body{expected_response=Something_else}, Soap_req, State) ->
    %% simply echo the message (used to test encodings)
    {ok, #response_body{response=Something_else}, Soap_req, State}.

%% replace the default exception handler to include a stacktrace.
-spec exception(Class::atom(), Reason::any(), Stacktrace::any(),
                soap:soap_fault_code(), Description::string(), soap:soap_req(), 
                soap:soap_handler_state()) -> soap:soap_handler_response().
exception(Class, Reason, Stacktrace, Type, _Desc, Soap_req, Handler_state) ->
    Message = io_lib:format("exception, class: ~p, reason: ~p,~nstack: ~P~n", 
                            [Class, Reason, Stacktrace, 14]),
    {fault, soap_fault:fault(Type, Message, Soap_req), Soap_req, Handler_state}. 

%% The 'interface()' function is used by the SOAP framework to access information about
%% the WSDL.
interface() ->
    ?INTERFACE.
